### Reflection on CS 305 Project Two

**Client summary:** Artemis Financial represents a fictional financial services entity in this CS 305 simulation, focused on developing an investigative tool for fraud detection. The client's primary software requirement was a reliable RESTful web server capable of securely transmitting sensitive data. The core issue addressed was the application's inherent vulnerabilities, including unencrypted HTTP communications, absence of data integrity mechanisms, and reliance on outdated dependencies harboring numerous CVEs, which collectively exposed the tool to risks such as interception and tampering.

**What I did well and why secure coding matters:** A key strength in identifying Artemis Financial's vulnerabilities was the systematic application of the Vulnerability Assessment Flow Diagram, which facilitated a structured progression from architecture review to targeted mitigations, such as integrating SHA-256 hashing and TLS encryption without disrupting core operations. Secure coding is essential in mitigating the financial and reputational repercussions of breaches, with average costs exceeding $4.45 million per incident (IBM, 2023). In the financial sector, it ensures regulatory compliance (e.g., PCI-DSS), minimizes operational disruptions, and cultivates stakeholder confidence, ultimately contributing to sustained organizational stability and growth.

**Challenging/helpful part:** The most challenging element of the vulnerability assessment was reconciling the rubric's expectations with the codebase's outdated dependencies, such as Spring Boot 2.2.4, which persisted in generating 147 CVEs even after mitigations, necessitating careful prioritization without full upgrades to avoid rubric misalignment. This highlighted conflicting decisions inherent to legacy systems. Conversely, the Cryptography step proved particularly helpful, as it illuminated practical layering techniques—like combining SHA-256 with TLS—that reinforced foundational concepts from *Iron-Clad Java* and enhanced my ability to navigate real-world trade-offs in secure refactoring.

**Layers of security and future assessment:** Security was augmented through defense-in-depth, incorporating integrity via SHA-256 checksums (Deploy Cipher), confidentiality through TLS_AES_256_GCM_SHA384 (Secure Communications), and detection with OWASP Dependency-Check scans (Secondary Testing). For future assessments, I would leverage SonarQube for automated static analysis and OWASP ZAP for dynamic testing, evaluating mitigations based on CVSS scores weighted by business context—e.g., prioritizing remote code execution over denial-of-service in high-stakes financial applications.

**Ensuring functional/secure:** Functionality and security were validated iteratively: Post-refactor, Maven builds (`mvn clean spring-boot:run`) confirmed error-free execution with consistent endpoint responses, while re-running Dependency-Check ensured no new vulnerabilities were introduced (legacy CVEs remained but were contextually mitigated). The manual Flow Diagram review provided an additional safeguard, cross-verifying logical flows and encapsulation without regressions.

**Resources/tools/practices:** Valuable resources included *Iron-Clad Java* for cryptographic patterns and whitelisting practices, keytool for certificate generation, and Maven Dependency-Check for CVE enumeration. Tools like Eclipse, though challenging due to compatibility with outdated dependencies, underscored the importance of version pinning. Practices such as explicit algorithm specification and comprehensive exception handling will be instrumental in subsequent tasks, promoting maintainable and audit-ready codebases.

