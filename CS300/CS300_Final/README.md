# CS300 Course Advising Assistant

## What was the problem you were solving in the projects for this course?

In this course, we completed assignments that demonstrated the speed and efficiency of common algorithms and data structures and their respective operations. By comparing strategies using Big O notation, we learned that certain data structures have advantages over others depending on whether memory or speed is the primary concern.

Since data is the backbone of any application, choosing the best structure to organize it is key to maintainability and scalability. Larger systems often require multiple data structures working together, but the fundamentals covered in this course helped me realize that these small design choices can make a big difference as input size grows.

## How did you approach the problem?

For this assignment, I wanted to understand the basics of hash tables before writing any code. In previous courses, we used higher-level languages that abstract a lot of the lower-level details from the programmer. C++ required a much deeper understanding to implement a hash table correctly, which gave me a new appreciation for what happens behind the scenes in other languages like Python.

Seeing the smaller operations directly in C++ helped me better understand how data structures really work and why it's important to choose the right one when working with a collection of data.

## How did you overcome any roadblocks you encountered while going through the activities or project?

One of the main challenges was designing and implementing the CSV reader. While other languages have built-in utilities for parsing CSVs, C++ required more manual work. Creating a reliable and flexible implementation took testing and iteration.

Before writing the code, I imagined scenarios where the CSV might not be formatted perfectly or could contain duplicate entries. Accounting for those situations early helped me design a more complete and robust solution that could handle real-world data issues.

## How has your work on this project expanded your approach to designing software and developing programs?

Working with C++ and focusing on data structures and algorithms gave me a much greater appreciation for what goes on at a lower level in software. When I use other languages that abstract these details, I'll now be more conscious of what's happening under the hood and why performance or memory differences occur.

This project reminded me that understanding the fundamentals allows you to make more informed design decisions about which tools and structures are best for a given problem.

## How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

With C++, I learned the importance of compiling and testing frequently instead of waiting until the end. I try to run as many small tests as possible— even something simple like a menu prompt—before moving on. No matter how experienced you are, small, consistent testing helps catch mistakes early and keeps the codebase stable.

By building and verifying small components one at a time, it's easier to find and fix bugs, and the final program is cleaner, more maintainable, and easier to adapt later.
